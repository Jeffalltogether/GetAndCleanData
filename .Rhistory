my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
# segments(1,0.38,1,0, lty=3)
# text(1,0.4, expression(paste(1, sigma, sep='')))
#
# segments(-1,0.38,-1,0, lty=3)
# text(-1,0.4, expression(paste(-1, sigma, sep='')))
#
# segments(2,0.28,2,0, lty=3)
# text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2.2,0.28,-2.2,0, lty=3)
text(-2.2,0.3, "Patient's Score")
segments(-2.4,0.28,-2.4,0, lty=3)
text(-2.4,0.3, "Patient's Score")
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
# segments(1,0.38,1,0, lty=3)
# text(1,0.4, expression(paste(1, sigma, sep='')))
#
# segments(-1,0.38,-1,0, lty=3)
# text(-1,0.4, expression(paste(-1, sigma, sep='')))
#
# segments(2,0.28,2,0, lty=3)
# text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2.4,0.28,-2.4,0, lty=3)
text(-2.4,0.3, "Patient's Score")
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
# segments(1,0.38,1,0, lty=3)
# text(1,0.4, expression(paste(1, sigma, sep='')))
#
# segments(-1,0.38,-1,0, lty=3)
# text(-1,0.4, expression(paste(-1, sigma, sep='')))
#
# segments(2,0.28,2,0, lty=3)
# text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2.5,0.28,-2.5,0, lty=3)
text(-2.5,0.3, "Patient's Score")
segments(-2.5,0.28,-2.5,0, lty=3)
text(-2.5,0.3, "Patient's \n Score")
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
# segments(1,0.38,1,0, lty=3)
# text(1,0.4, expression(paste(1, sigma, sep='')))
#
# segments(-1,0.38,-1,0, lty=3)
# text(-1,0.4, expression(paste(-1, sigma, sep='')))
#
# segments(2,0.28,2,0, lty=3)
# text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2.5,0.28,-2.5,0, lty=3)
text(-2.5,0.3, "Patient's \n Score")
#################
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
# segments(1,0.38,1,0, lty=3)
# text(1,0.4, expression(paste(1, sigma, sep='')))
#
# segments(-1,0.38,-1,0, lty=3)
# text(-1,0.4, expression(paste(-1, sigma, sep='')))
#
# segments(2,0.28,2,0, lty=3)
# text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2.5,0.26,-2.5,0, lty=3)
text(-2.5,0.3, "Patient's \n Score")
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
segments(1,0.38,1,0, lty=3)
text(1,0.4, expression(paste(1, sigma, sep='')))
segments(-1,0.38,-1,0, lty=3)
text(1,0.4, expression(paste(-1, sigma, sep='')))
segments(2,0.28,2,0, lty=3)
text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2,0.28,-2,0, lty=3)
text(-2,0.3, expression(paste(2, sigma, sep='')))
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
segments(1,0.38,1,0, lty=3)
text(1,0.4, expression(paste(1, sigma, sep='')))
segments(-1,0.38,-1,0, lty=3)
text(1,0.4, expression(paste(1, sigma, sep='')))
segments(2,0.28,2,0, lty=3)
text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2,0.28,-2,0, lty=3)
text(-2,0.3, expression(paste(2, sigma, sep='')))
pnorm(5)
1-pnorm(5)
# Here is the code for the graph. I wrote it in a hurry, any suggestion to make it better is welcome.
my.color   <- c("blue", "yellow", "red")
my.symbol2 <- expression(mu)
my.axis    <- c(-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6)
my.label   <- c('-6', '-5','-4','-3','-2','-1',my.symbol2,'1','2','3','4','5','6')
x = seq(-6, 6, length = 600)
y = dnorm(x)
plot(x, y, type = "n", xlab="Z-score", ylab="", axes=FALSE)
plotsigma <- function(start, end, color){
sigmax = seq(start, end, length=100)
sigmay = c(0, dnorm(sigmax), 0)
sigmax = c(start, sigmax, end)
polygon(sigmax, sigmay, col = color, border = NA)
}
for (i in 5:1){
plotsigma(-i, i, my.color[i])
}
axis(1,at=my.axis,labels=my.label)
lines(x, y)
segments(0,0.4,0,0, col='white')
segments(1,0.38,1,0, lty=3)
text(1,0.4, expression(paste(1, sigma, sep='')))
segments(-1,0.38,-1,0, lty=3)
text(-1,0.4, expression(paste(1, sigma, sep='')))
segments(2,0.28,2,0, lty=3)
text(2,0.3, expression(paste(2, sigma, sep='')))
segments(-2,0.28,-2,0, lty=3)
text(-2,0.3, expression(paste(2, sigma, sep='')))
### http://biostatistics.oxfordjournals.org/content/10/1/94.full
library(bdpv)
# se =          # a (vector of) numeric value(s), specifying the expected sensitivity
# sp =          # a (vector of) numeric value(s), specifying the expected specificity
# prev =        # a (vector of) numeric value(s), specifying the prevalence
# NPV0 =        # a (vector of) numeric value(s), specifying the negative predictive value to be rejected under H0: NPV>=NPV0
# PPV0 =        # a (vector of) numeric value(s), specifying the positive predictive value to be rejected under H0: PPV>=PPV0
# NPVpower =    # a (vector of) numeric value(s), the power that is to be obtained for the test H0:NPV>=NPV0
# PPVpower =    # a (vector of) numeric value(s), the power that is to be obtained for the test H0:PPV>=PV0
# rangeP =      # a vector of two numeric values, giving the range of the proportion of truely positives to be considered in experimental design
# nsteps =      # a single (integer) value, the number of steps in rangeP to be considered
# alpha =       # a single numeric value, the type I error of the test (1-confidence level)
# setnames =    # an optional vector of names for the parameter sets
## Research the prevalence of the disease in the population
prev = 0.6 #PAD prevalence for age 55+ with risk factors
## Chosing the parameters for the desired results of our test
# se = seq(0.7, 1.0, 0.05)
# sp = seq(0.7, 1.0, 0.05)
se = 0.90
sp = 0.90
## Determine NPV0 and PPV0
currentSE = 0.71   # sensitivity of current test to beat
currentSP = 0.67   # specificity of current test to beat
## Positive and negative predictive values
PPV0 = (prev*currentSE)/(prev*currentSE+(1-prev)*(1-currentSP))
NPV0 = ((1-prev)*currentSP)/(prev*(1-currentSE)+(1-prev)*currentSP)
## Calculate Sample Size
result <- nPV(se, sp, prev, NPV0, PPV0,
NPVpower = 0.8, PPVpower = 0.8,
rangeP = c(0.05, 0.95), nsteps = 30,
alpha = 0.05, setnames = NULL)
print(result)
# outDAT a data.frame showing the parameter settings (in rows) and the input parameters se, sp, prev, NPV0, PPV0, NPVpower, PPVpower, trueNPV, truePPV
# nlist a list with an element for each parameter setting in OUTDAT, listing the results of nNPV, and nPPV
# NSETS a single (integer), the number of parameter sets
# nsteps a single (integer), the number of steps in the range of proportions of true positives
# rangeP the input range of the proportion of true positives
# propP the resulting sequence of proportions of true positives considere
## Plot Result
plotnPV(result, log = "y", NPVpar = list(col=3, lwd=2, lty=1),
PPVpar = list(col=4, lwd=2, lty=1),
xlab="Proportion of true positives in study cohort, n1/(n0+n1) \n n0 = PAD negative     n1 = PAD positive",
ylab="Total sample size, (n0+n1)",
main="Diagnostic Clinical Performance Study \nSample Size Estimate")
currentSE = 0.90   # sensitivity of current test to beat
currentSP = 0.90   # specificity of current test to beat
## Positive and negative predictive values
PPV0 = (prev*currentSE)/(prev*currentSE+(1-prev)*(1-currentSP))
NPV0 = ((1-prev)*currentSP)/(prev*(1-currentSE)+(1-prev)*currentSP)
se = 0.90
sp = 0.90
desiredPPV = (prev*currentSE)/(prev*currentSE+(1-prev)*(1-currentSP))
desiredNPV = ((1-prev)*currentSP)/(prev*(1-currentSE)+(1-prev)*currentSP)
## Determine NPV0 and PPV0
currentSE = 0.71   # sensitivity of current test to beat
currentSP = 0.67   # specificity of current test to beat
## Positive and negative predictive values
## Chosing the parameters for the desired results of our test
# se = seq(0.7, 1.0, 0.05)
# sp = seq(0.7, 1.0, 0.05)
se = 0.90
sp = 0.90
desiredPPV = (prev*se)/(prev*se+(1-prev)*(1-sp))
desiredNPV= ((1-prev)*sp)/(prev*(1-se)+(1-prev)*sp)
currentSE = 0.71   # sensitivity of current test to beat
currentSP = 0.67   # specificity of current test to beat
## Positive and negative predictive values
PPV0 = (prev*currentSE)/(prev*currentSE+(1-prev)*(1-currentSP))
NPV0 = ((1-prev)*currentSP)/(prev*(1-currentSE)+(1-prev)*currentSP)
library(bdpv)
# se =          # a (vector of) numeric value(s), specifying the expected sensitivity
# sp =          # a (vector of) numeric value(s), specifying the expected specificity
# prev =        # a (vector of) numeric value(s), specifying the prevalence
# NPV0 =        # a (vector of) numeric value(s), specifying the negative predictive value to be rejected under H0: NPV>=NPV0
# PPV0 =        # a (vector of) numeric value(s), specifying the positive predictive value to be rejected under H0: PPV>=PPV0
# NPVpower =    # a (vector of) numeric value(s), the power that is to be obtained for the test H0:NPV>=NPV0
# PPVpower =    # a (vector of) numeric value(s), the power that is to be obtained for the test H0:PPV>=PV0
# rangeP =      # a vector of two numeric values, giving the range of the proportion of truely positives to be considered in experimental design
# nsteps =      # a single (integer) value, the number of steps in rangeP to be considered
# alpha =       # a single numeric value, the type I error of the test (1-confidence level)
# setnames =    # an optional vector of names for the parameter sets
## Research the prevalence of the disease in the population
prev = 0.6 #PAD prevalence for age 55+ with risk factors
## Chosing the parameters for the desired results of our test
# se = seq(0.7, 1.0, 0.05)
# sp = seq(0.7, 1.0, 0.05)
se = 0.80
sp = 0.80
desiredPPV = (prev*se)/(prev*se+(1-prev)*(1-sp))
desiredNPV= ((1-prev)*sp)/(prev*(1-se)+(1-prev)*sp)
## Determine NPV0 and PPV0
currentSE = 0.71   # sensitivity of current test to beat
currentSP = 0.67   # specificity of current test to beat
## Positive and negative predictive values
PPV0 = (prev*currentSE)/(prev*currentSE+(1-prev)*(1-currentSP))
NPV0 = ((1-prev)*currentSP)/(prev*(1-currentSE)+(1-prev)*currentSP)
## Calculate Sample Size
result <- nPV(se, sp, prev, NPV0, PPV0,
NPVpower = 0.8, PPVpower = 0.8,
rangeP = c(0.05, 0.95), nsteps = 30,
alpha = 0.05, setnames = NULL)
print(result)
# outDAT a data.frame showing the parameter settings (in rows) and the input parameters se, sp, prev, NPV0, PPV0, NPVpower, PPVpower, trueNPV, truePPV
# nlist a list with an element for each parameter setting in OUTDAT, listing the results of nNPV, and nPPV
# NSETS a single (integer), the number of parameter sets
# nsteps a single (integer), the number of steps in the range of proportions of true positives
# rangeP the input range of the proportion of true positives
# propP the resulting sequence of proportions of true positives considere
## Plot Result
plotnPV(result, log = "y", NPVpar = list(col=3, lwd=2, lty=1),
PPVpar = list(col=4, lwd=2, lty=1),
xlab="Proportion of true positives in study cohort, n1/(n0+n1) \n n0 = PAD negative     n1 = PAD positive",
ylab="Total sample size, (n0+n1)",
main="Diagnostic Clinical Performance Study \nSample Size Estimate")
library(bdpv)
# se =          # a (vector of) numeric value(s), specifying the expected sensitivity
# sp =          # a (vector of) numeric value(s), specifying the expected specificity
# prev =        # a (vector of) numeric value(s), specifying the prevalence
# NPV0 =        # a (vector of) numeric value(s), specifying the negative predictive value to be rejected under H0: NPV>=NPV0
# PPV0 =        # a (vector of) numeric value(s), specifying the positive predictive value to be rejected under H0: PPV>=PPV0
# NPVpower =    # a (vector of) numeric value(s), the power that is to be obtained for the test H0:NPV>=NPV0
# PPVpower =    # a (vector of) numeric value(s), the power that is to be obtained for the test H0:PPV>=PV0
# rangeP =      # a vector of two numeric values, giving the range of the proportion of truely positives to be considered in experimental design
# nsteps =      # a single (integer) value, the number of steps in rangeP to be considered
# alpha =       # a single numeric value, the type I error of the test (1-confidence level)
# setnames =    # an optional vector of names for the parameter sets
## Research the prevalence of the disease in the population
prev = 0.6 #PAD prevalence for age 55+ with risk factors
## Chosing the parameters for the desired results of our test
# se = seq(0.7, 1.0, 0.05)
# sp = seq(0.7, 1.0, 0.05)
se = 0.86
sp = 0.79
desiredPPV = (prev*se)/(prev*se+(1-prev)*(1-sp))
desiredNPV= ((1-prev)*sp)/(prev*(1-se)+(1-prev)*sp)
## Determine NPV0 and PPV0
currentSE = 0.71   # sensitivity of current test to beat
currentSP = 0.67   # specificity of current test to beat
## Positive and negative predictive values
PPV0 = (prev*currentSE)/(prev*currentSE+(1-prev)*(1-currentSP))
NPV0 = ((1-prev)*currentSP)/(prev*(1-currentSE)+(1-prev)*currentSP)
## Calculate Sample Size
result <- nPV(se, sp, prev, NPV0, PPV0,
NPVpower = 0.8, PPVpower = 0.8,
rangeP = c(0.05, 0.95), nsteps = 30,
alpha = 0.05, setnames = NULL)
print(result)
# outDAT a data.frame showing the parameter settings (in rows) and the input parameters se, sp, prev, NPV0, PPV0, NPVpower, PPVpower, trueNPV, truePPV
# nlist a list with an element for each parameter setting in OUTDAT, listing the results of nNPV, and nPPV
# NSETS a single (integer), the number of parameter sets
# nsteps a single (integer), the number of steps in the range of proportions of true positives
# rangeP the input range of the proportion of true positives
# propP the resulting sequence of proportions of true positives considere
## Plot Result
plotnPV(result, log = "y", NPVpar = list(col=3, lwd=2, lty=1),
PPVpar = list(col=4, lwd=2, lty=1),
xlab="Proportion of true positives in study cohort, n1/(n0+n1) \n n0 = PAD negative     n1 = PAD positive",
ylab="Total sample size, (n0+n1)",
main="Diagnostic Clinical Performance Study \nSample Size Estimate")
library(data.table)
library(dplyr)
library(tidyr)
setwd("C:/Users/jeffthatcher/Cloud Drive/RRepos/GetCleanData")
fileUrl <- "https://drive.google.com/file/d/0BwSh24a5hm4kSERESlFkeHZXOFE/view?usp=sharing"
download.file(fileUrl, destfile = "./data/graphData.csv") #curl is necessary for MAC users getting data from https
list.files("./data") # sort of like the ls() command, shows the files in the directory "./data"
idaho <- read.csv("./data/graphData.csv")
setwd("C:/Users/jeffthatcher/Cloud Drive/RRepos/GetCleanData")
fileUrl <- "https://drive.google.com/file/d/0BwSh24a5hm4kSERESlFkeHZXOFE/view?usp=sharing"
download.file(fileUrl, destfile = "./data/graphData.csv") #curl is necessary for MAC users getting data from https
if(!file.exists("data")) {
dir.create("data")
}
if(!file.exists("data")) {
dir.create("data")
}
}
setwd("C:/Users/jeffthatcher/Cloud Drive/RRepos/GetCleanData")
fileUrl <- "https://drive.google.com/file/d/0BwSh24a5hm4kSERESlFkeHZXOFE/view?usp=sharing"
download.file(fileUrl, destfile = "./data/graphData.csv") #curl is necessary for MAC users getting data from https
list.files("./data") # sort of like the ls() command, shows the files in the directory "./data"
DT <- read.csv("./data/graphData.csv")
download.file(fileUrl, destfile = "./data/graphData.csv") #curl is necessary for MAC users getting data from https
download.file(fileUrl, destfile = "./data/graphData.csv", mode="wb") #curl is necessary for MAC users getting data from https
list.files("./data") # sort of like the ls() command, shows the files in the directory "./data"
DT <- read.csv("./data/graphData.csv")
setwd("C:/Users/jeffthatcher/Cloud Drive/RRepos/GetCleanData")
fileUrl <- "https://drive.google.com/file/d/0BwSh24a5hm4kSERESlFkeHZXOFE/view?usp=sharing"
download.file(fileUrl, destfile = "./data/graphData.csv", mode="wb") #curl is necessary for MAC users getting data from https
list.files("./data") # sort of like the ls() command, shows the files in the directory "./data"
DT <- read.csv("./data/graphData.csv")
setwd("C:/Users/jeffthatcher/Cloud Drive/RRepos/GetCleanData")
# http://stackoverflow.com/questions/29523974/cleaning-data-when-variables-are-column-names/29526525?iemail=1&noredirect=1#29526525
setwd("C:/Users/jeffthatcher/Cloud Drive/RRepos/GetCleanData")
library(data.table)
library(dplyr)
library(tidyr)
DT <- read.csv("./data/unCleanData.csv")
?setDT
melt(setDT(DT), id=1L, measure=lapply(c("^Group", "^Error"), grep, names(dt)),
variable.name="Group", value.name = c("Measure", "Error"))
library(data.table)
library(dplyr)
library(tidyr)
DT <- read.csv("./data/unCleanData.csv")
melt(setDT(DT), id=1L, measure=lapply(c("^Group", "^Error"), grep, names(dt)),
variable.name="Group", value.name = c("Measure", "Error"))
install.packages("data.table")
df <- read.csv("./data/unCleanData.csv")
library(devtools)
find_rtools()
library(dplyr)
df <- data.frame(Timepoint=c(0L, 7L, 14L, 21L, 28L), Group1=c(50L, 60L, 66L, 88L, 90L),
Error_Group1=c(3, 4, 6, 8, 2), Group2=c(30L, 60L, 90L, 120L, 150L),
Error_Group2=c(10L, 14L, 16L, 13L, 25L), Group3=c(44L, 78L, 64L, 88L, 91L),
Error_Group3=c(2L, 13L, 16L, 4L, 9L))
df <- lapply(1:3, function(x){
temp <- df %>% select(Timepoint, ends_with(as.character(x))) %>% mutate(Group=x)
names(temp) <- c("Timepoint", "Measure", "Error", "Group")
temp <- temp %>% select(Timepoint, Group, Measure, Error)
})
df <- do.call(rbind, df)
df
df <- read.csv("./data/unCleanData.csv")
library(dplyr); library(tidyr)
df <- df %>% gather(temp, Timepoint)
names(df) <- c("Timepoint", "temp", "values")
df <- df %>% mutate(Group = sub("\\D+", "", temp), temp=sub("\\d", "", temp)) %>%
spread(temp, values)
names(df) <- c("Timepoint", "Group", "Error", "Measure")
df
df <- read.csv("./data/unCleanData.csv")
df %>%
# 1. Pivot the table
gather (g, m, -Timepoint) %>%
# 2. Get the final Group ID in mGroup
separate (g, c("Measure", "mGroup"), -2) %>%
# 3. Spread the actual Error and Measure in two columns
spread (Measure, m) %>%
# 4. Assign the correct names to final columns
select (Timepoint, Group = mGroup, Measure = Group, Error = Error_Group) %>%
# 5. Sort as requested
arrange (Group, Timepoint)
library(devtools)
install_github("Rdatatable/data.table", build_vignettes = FALSE)
# First you must install RTools at the following URL
# http://cran.r-project.org/bin/windows/Rtools/
library(devtools)
install_github("Rdatatable/data.table", build_vignettes = FALSE)
melt(setDT(DT), id=1L, measure=lapply(c("^Group", "^Error"), grep, names(dt)),
variable.name="Group", value.name = c("Measure", "Error"))
remove.packages("data.table")         # First remove the current version
install_github("Rdatatable/data.table", build_vignettes = FALSE)
library(reshape)
install.packages("reshap")
library(reshape2)
melt(setDT(DT), id=1L, measure=lapply(c("^Group", "^Error"), grep, names(dt)),
variable.name="Group", value.name = c("Measure", "Error"))
df <- read.csv("./data/unCleanData.csv")
melt(df)
?metl
?melt
